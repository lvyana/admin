(self.webpackChunkreact_app=self.webpackChunkreact_app||[]).push([[9051],{14532:(e,t,s)=>{"use strict";s.d(t,{A:()=>i});s(65043);var r=s(27371),n=s(96029);const o=e=>{let{items:t,styleConfig:s,style:r,bordered:o}=e;const{token:d}=(0,n.A)(),i={marginBottom:24,background:d.colorFillAlter,borderRadius:d.borderRadiusLG,border:"none"};if("1"===s){return{list:null==t?void 0:t.map((e=>({...e,style:i}))),style:{background:d.colorBgContainer},bordered:!1}}return{items:t,styleConfig:s,style:r,bordered:o}};var d=s(70579);const i=e=>{let{...t}=e;const{items:s,styleConfig:n,style:i,bordered:l,...c}=t,a=o({items:s,styleConfig:n,style:i,bordered:l});return(0,d.jsx)(r.A,{...c,bordered:a.bordered,style:a.style,items:a.list})}},62560:(e,t,s)=>{"use strict";s.d(t,{A:()=>l});var r=s(65043),n=s(91228),o=s.n(n),d=s(82999),i=(s(83241),s(53636),s(15575),s(15696),s(70579));const l=e=>{let{initCode:t="function add(a, b) {\n  return a + b;\n}"}=e;const[s,n]=(0,r.useState)(t);return(0,i.jsx)(o(),{value:s,onValueChange:e=>n(e),highlight:e=>(0,d.highlight)(e,d.languages.js,"jsx"),padding:10,style:{fontSize:14},readOnly:!0,disabled:!0})}},6261:(e,t,s)=>{"use strict";s.d(t,{A:()=>a});var r=s(96029),n=s(65043),o=s(53768),d=s(37537),i=s(27693);const l="iMarkdown_codeStyle__rdowo";var c=s(70579);const a=e=>{let{url:t="",initContent:a=""}=e;const[u,h]=(0,n.useState)(a);(0,n.useEffect)((()=>{t&&x()}),[]);const x=()=>{try{s(42784)("./"+t).then((e=>{fetch(e.default).then((e=>e.text())).then((e=>{h(e)}))}))}catch(e){}},{token:j}=(0,r.A)();return(0,n.useEffect)((()=>{var e;null===(e=document.querySelector("pre"))||void 0===e||e.style.setProperty("background-color",j.colorBgBase)}),[]),(0,c.jsx)("div",{children:(0,c.jsx)(o.$,{className:l,components:{code(e){let{node:t,inline:s,className:r,children:n,...o}=e;const l=/language-(\w+)/.exec(r||"");return!s&&l?(0,c.jsx)(d.A,{language:l[1],PreTag:"div",...o,style:i.A,children:String(n).replace(/\n$/,"")}):(0,c.jsx)("code",{className:r,...o,children:n})}},children:u})})}},37767:(e,t,s)=>{"use strict";s.r(t),s.d(t,{default:()=>u});var r=s(65043),n=s(87021),o=s(76566),d=s(14532),i=s(62560),l=s(60198),c=s(6261),a=s(70579);const u=()=>{const[e,t]=(0,r.useState)(0),[s,u]=(0,r.useState)((()=>0)),h=[{label:"useState在组件式编程里的基本用处",children:(0,a.jsx)("div",{children:"useState 是一个组件定义状态信息,所谓“状态”,就是该组件任意时刻都存放的各种数据"}),key:"0"},{label:"useState更新",children:(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("div",{children:"1、当组件更新state时,会触发组件的重新渲染,可以认为发生了局部刷新"}),(0,a.jsx)("div",{children:"2、在函数内多次更新,会合并处理"}),(0,a.jsx)("div",{children:"3、18之前手动合并处理unstable_batchedUpdates,18之后自动合并处理就不需要了"})]}),key:"1"},{label:"代码示例",children:(0,a.jsx)(a.Fragment,{children:(0,a.jsx)(i.A,{initCode:"\nimport { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  function handleClick() {\n    setCount(count + 1);\n  }\n\n  return (\n    <button onClick={handleClick}>\n      You pressed me {count} times\n    </button>\n  );\n};"})}),key:"2"}];return(0,a.jsxs)(o.A,{children:[(0,a.jsx)(n.Ay,{type:"link",onClick:()=>{setTimeout((()=>t(e+1)),1e3),setTimeout((()=>t(e+1)),1e3),setTimeout((()=>u(s+1)),2e3)},children:"+1"}),e,s,(0,a.jsx)(d.A,{styleConfig:"1",defaultActiveKey:["0"],items:h}),(0,a.jsx)(l.IuseSyncExternalStoreItem,{}),(0,a.jsx)(c.A,{url:"useState.md"})]})}},60198:(e,t,s)=>{"use strict";s.r(t),s.d(t,{IuseSyncExternalStore:()=>x,IuseSyncExternalStoreItem:()=>j,default:()=>S});var r=s(65043);let n=0,o=[{id:n++,text:"Todo #1"}],d=[];function i(){for(let e of d)e()}const l={addTodo(){o=[...o,{id:n++,text:"Todo #"+n}],i()},deleteTodo(){o=o.filter(((e,t)=>0!==t)),i()},subscribe:e=>(d=[...d,e],()=>{d=d.filter((t=>t!==e))}),getSnapshot:()=>o};var c=s(76566),a=s(90638),u=s(14532),h=s(70579);const x=()=>{const e=(0,r.useSyncExternalStore)(l.subscribe,l.getSnapshot),t={name:"Add todo",type:"primary",onClick:()=>l.addTodo()};return(0,h.jsxs)(c.A,{children:[(0,h.jsx)(a.A,{...t}),(0,h.jsx)("hr",{}),(0,h.jsx)("ul",{children:e.map((e=>(0,h.jsx)("li",{children:e.text},e.id)))}),(0,h.jsx)(j,{}),(0,h.jsx)(y,{})]})},j=()=>{const e=(0,r.useSyncExternalStore)(l.subscribe,l.getSnapshot),t={name:"Add todo",type:"primary",onClick:()=>l.addTodo()},s={name:"delete todo",type:"primary",onClick:()=>l.deleteTodo()};return(0,h.jsxs)("div",{children:[(0,h.jsx)("div",{children:"测试: useSyncExternalStore数据可以共享"}),(0,h.jsx)(a.A,{...t}),(0,h.jsx)(a.A,{...s}),(0,h.jsx)("hr",{}),(0,h.jsx)("ul",{children:e.map((e=>(0,h.jsx)("li",{children:e.text},e.id)))})]})},b=[{header:"useSyncExternalStore 参数说明",content:(0,h.jsxs)(h.Fragment,{children:[(0,h.jsx)("div",{children:"useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot)"}),(0,h.jsx)("div",{children:"subscribe函数得订阅这个store, 并且返回一个可以取消订阅的函数。"}),(0,h.jsx)("div",{children:"getSnapshot函数得可以从store里读取数据快照。"}),(0,h.jsx)("div",{children:"subscribe: 是一个函数，只有一个回调函数作为入参，并且使其订阅这个store. 当store发生改变的时候，这个回调函数应该得到执行，而且这会触发组件的重新渲染。subscribe函数应该返回一个可以取消订阅的方法。"}),(0,h.jsx)("div",{children:"getSnapshot: 是一个函数，返回一个组件中需要用到的store里的一个数据值的快照。当这个store没有改变的时候，重复调用getSnapshot必须返回同样的值。如果store发生改变并且返回的数据值不一样了（用Object.js做比较），那么Reacr重新渲染这个组件。"}),(0,h.jsx)("div",{children:"getServerSnapshot（可选参数）: 是一个函数，返回store数据的初始快照。只会在服务端渲染的时候使用，并且是在服务端渲染好的内容往客户端灌水的时候。服务端的快照必须和客户端的一致。并且通常是序列化后被发送到客户端的，如果你不传这个参数，在服务端渲染的时候会报错"}),(0,h.jsx)("div",{children:"当前你在组件渲染中使用到的store数据的快照"}),(0,h.jsx)("div",{children:"警告"}),(0,h.jsx)("div",{children:"调用getSnapshot返回的这个store数据快照不能修改，如果所依赖的store有可以更改的数据，当数据发生改变返回新的不可修改的数据，否则返回上一次缓存的数据快照。"}),(0,h.jsx)("div",{children:"如果在重新渲染的时候传来一个不同的subscribe函数，React会用新的subscribe重新订阅这个store。你可以通过在组件外面声明subscribe的方式来避免"})]}),key:"1"}],y=()=>(0,h.jsx)(u.A,{items:b}),S=x},42784:(e,t,s)=>{var r={"./branch.md":[4297,4297],"./reactRouterDomV6.md":[60335,335],"./useState.md":[59989,9989]};function n(e){if(!s.o(r,e))return Promise.resolve().then((()=>{var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}));var t=r[e],n=t[0];return s.e(t[1]).then((()=>s.t(n,17)))}n.keys=()=>Object.keys(r),n.id=42784,e.exports=n}}]);