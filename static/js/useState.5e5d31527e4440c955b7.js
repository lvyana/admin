"use strict";(self.webpackChunkreact_app=self.webpackChunkreact_app||[]).push([[9126],{68792:(e,t,s)=>{s.d(t,{Z:()=>i});s(72791);var n=s(16421),r=s(83298);const o=e=>{let{list:t,styleConfig:s,style:n,bordered:o}=e;const{token:d}=(0,r.Z)(),i={marginBottom:24,background:d.colorFillAlter,borderRadius:d.borderRadiusLG,border:"none"};if("1"===s){return{list:null==t?void 0:t.map((e=>({...e,style:i}))),style:{background:d.colorBgContainer},bordered:!1}}return{list:t,styleConfig:s,style:n,bordered:o}};var d=s(80184);const i=e=>{let{list:t,defaultActiveKey:s,styleConfig:r,bordered:i=!0,onChange:l,expandIcon:c,style:a}=e;const u=o({list:t,styleConfig:r,style:a,bordered:i});return(0,d.jsx)(n.Z,{bordered:u.bordered,defaultActiveKey:s,onChange:l,expandIcon:c,style:u.style,items:u.list})}},4429:(e,t,s)=>{s.d(t,{Z:()=>l});var n=s(72791),r=s(94044),o=s.n(r),d=s(61293),i=(s(44350),s(99465),s(6639),s(27862),s(80184));const l=e=>{let{initCode:t="function add(a, b) {\n  return a + b;\n}"}=e;const[s,r]=(0,n.useState)(t);return(0,i.jsx)(o(),{value:s,onValueChange:e=>r(e),highlight:e=>(0,d.highlight)(e,d.languages.js,"jsx"),padding:10,style:{fontSize:14},readOnly:!0,disabled:!0})}},77982:(e,t,s)=>{s.r(t),s.d(t,{default:()=>u});var n=s(72791),r=s(2641),o=s(94805),d=s(68792),i=s(4429),l=s(18372),c=s(49499),a=s(80184);const u=()=>{const[e,t]=(0,n.useState)(0),[s,u]=(0,n.useState)((()=>0)),h=[{label:"useState在组件式编程里的基本用处",children:(0,a.jsx)("div",{children:"useState 是一个组件定义状态信息,所谓“状态”,就是该组件任意时刻都存放的各种数据"}),key:"0"},{label:"useState更新",children:(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("div",{children:"1、当组件更新state时,会触发组件的重新渲染,可以认为发生了局部刷新"}),(0,a.jsx)("div",{children:"2、在函数内多次更新,会合并处理"}),(0,a.jsx)("div",{children:"3、18之前手动合并处理unstable_batchedUpdates,18之后自动合并处理就不需要了"})]}),key:"1"},{label:"代码示例",children:(0,a.jsx)(a.Fragment,{children:(0,a.jsx)(i.Z,{initCode:"\nimport { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  function handleClick() {\n    setCount(count + 1);\n  }\n\n  return (\n    <button onClick={handleClick}>\n      You pressed me {count} times\n    </button>\n  );\n};"})}),key:"2"}];return(0,a.jsxs)(o.Z,{children:[(0,a.jsx)(r.ZP,{type:"link",onClick:()=>{setTimeout((()=>t(e+1)),1e3),setTimeout((()=>t(e+1)),1e3),setTimeout((()=>u(s+1)),2e3)},children:"+1"}),e,s,(0,a.jsx)(d.Z,{styleConfig:"1",defaultActiveKey:["0"],list:h}),(0,a.jsx)(l.IuseSyncExternalStoreItem,{}),(0,a.jsx)(c.Z,{url:"useState.md"})]})}},18372:(e,t,s)=>{s.r(t),s.d(t,{IuseSyncExternalStore:()=>b,IuseSyncExternalStoreItem:()=>j,default:()=>g});var n=s(72791);let r=0,o=[{id:r++,text:"Todo #1"}],d=[];function i(){for(let e of d)e()}const l={addTodo(){o=[...o,{id:r++,text:"Todo #"+r}],i()},deleteTodo(){o=o.filter(((e,t)=>0!==t)),i()},subscribe:e=>(d=[...d,e],()=>{d=d.filter((t=>t!==e))}),getSnapshot:()=>o};var c=s(94805),a=s(98010),u=s(68792),h=s(80184);const x={name:"Add todo",type:"key",btnType:"primary"},b=()=>{const e=(0,n.useSyncExternalStore)(l.subscribe,l.getSnapshot);return(0,h.jsxs)(c.Z,{children:[(0,h.jsx)(a.Z,{buttonItem:x,onClick:()=>l.addTodo()}),(0,h.jsx)("hr",{}),(0,h.jsx)("ul",{children:e.map((e=>(0,h.jsx)("li",{children:e.text},e.id)))}),(0,h.jsx)(j,{}),(0,h.jsx)(y,{})]})},j=()=>{const e=(0,n.useSyncExternalStore)(l.subscribe,l.getSnapshot);return(0,h.jsxs)("div",{children:[(0,h.jsx)("div",{children:"测试: useSyncExternalStore数据可以共享"}),(0,h.jsx)(a.Z,{buttonItem:x,onClick:()=>l.addTodo()}),(0,h.jsx)(a.Z,{buttonItem:{...x,name:"delete todo"},onClick:()=>l.deleteTodo()}),(0,h.jsx)("hr",{}),(0,h.jsx)("ul",{children:e.map((e=>(0,h.jsx)("li",{children:e.text},e.id)))})]})},S=[{header:"useSyncExternalStore 参数说明",content:(0,h.jsxs)(h.Fragment,{children:[(0,h.jsx)("div",{children:"useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot)"}),(0,h.jsx)("div",{children:"subscribe函数得订阅这个store, 并且返回一个可以取消订阅的函数。"}),(0,h.jsx)("div",{children:"getSnapshot函数得可以从store里读取数据快照。"}),(0,h.jsx)("div",{children:"subscribe: 是一个函数，只有一个回调函数作为入参，并且使其订阅这个store. 当store发生改变的时候，这个回调函数应该得到执行，而且这会触发组件的重新渲染。subscribe函数应该返回一个可以取消订阅的方法。"}),(0,h.jsx)("div",{children:"getSnapshot: 是一个函数，返回一个组件中需要用到的store里的一个数据值的快照。当这个store没有改变的时候，重复调用getSnapshot必须返回同样的值。如果store发生改变并且返回的数据值不一样了（用Object.js做比较），那么Reacr重新渲染这个组件。"}),(0,h.jsx)("div",{children:"getServerSnapshot（可选参数）: 是一个函数，返回store数据的初始快照。只会在服务端渲染的时候使用，并且是在服务端渲染好的内容往客户端灌水的时候。服务端的快照必须和客户端的一致。并且通常是序列化后被发送到客户端的，如果你不传这个参数，在服务端渲染的时候会报错"}),(0,h.jsx)("div",{children:"当前你在组件渲染中使用到的store数据的快照"}),(0,h.jsx)("div",{children:"警告"}),(0,h.jsx)("div",{children:"调用getSnapshot返回的这个store数据快照不能修改，如果所依赖的store有可以更改的数据，当数据发生改变返回新的不可修改的数据，否则返回上一次缓存的数据快照。"}),(0,h.jsx)("div",{children:"如果在重新渲染的时候传来一个不同的subscribe函数，React会用新的subscribe重新订阅这个store。你可以通过在组件外面声明subscribe的方式来避免"})]}),key:"1"}],y=()=>(0,h.jsx)(u.Z,{list:S}),g=b}}]);