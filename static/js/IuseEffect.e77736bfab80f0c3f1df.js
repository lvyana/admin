"use strict";(self.webpackChunkreact_app=self.webpackChunkreact_app||[]).push([[9967],{68792:function(n,e,t){t.d(e,{Z:function(){return a}});t(72791);var r=t(16421),o=t(1413),u=t(83298),c=function(n){var e=n.list,t=n.styleConfig,r=n.style,c=n.bordered,i=(0,u.Z)().token,s={marginBottom:24,background:i.colorFillAlter,borderRadius:i.borderRadiusLG,border:"none"};return"1"===t?{list:e.map((function(n){return(0,o.Z)((0,o.Z)({},n),{},{style:s})})),style:{background:i.colorBgContainer},bordered:!1}:{list:e,styleConfig:t,style:r,bordered:c}},i=t(80184),s=r.Z.Panel,a=function(n){var e=n.list,t=n.defaultActiveKey,o=n.styleConfig,u=n.bordered,a=void 0===u||u,d=n.onChange,l=n.expandIcon,f=n.style,h=c({list:e,styleConfig:o,style:f,bordered:a});return(0,i.jsx)(r.Z,{bordered:h.bordered,defaultActiveKey:t,onChange:d,expandIcon:l,style:h.style,children:h.list.map((function(n){return(0,i.jsx)(s,{header:n.header,style:n.style,className:n.className,children:n.content},n.key)}))})}},4429:function(n,e,t){var r=t(29439),o=t(72791),u=t(94044),c=t.n(u),i=t(61293),s=(t(44350),t(99465),t(6639),t(27862),t(80184));e.Z=function(n){var e=n.initCode,t=void 0===e?"function add(a, b) {\n  return a + b;\n}":e,u=(0,o.useState)(t),a=(0,r.Z)(u,2),d=a[0],l=a[1];return(0,s.jsx)(c(),{value:d,onValueChange:function(n){return l(n)},highlight:function(n){return(0,i.highlight)(n,i.languages.js,"jsx")},padding:10,style:{fontSize:14},readOnly:!0,disabled:!0})}},64241:function(n,e,t){t.r(e);var r=t(29439),o=t(72791),u=t(87309),c=t(94805),i=t(68792),s=t(4429),a=t(80184),d=[{header:"执行机制",content:"浏览器渲染之后执行,不会阻塞渲染",key:"0"},{header:"无参数",content:"每次 reader 都会执行",key:"1"},{header:"空数组 []",content:"组件初始化执行一次",key:"2"},{header:"数组并且有参数 [a,b]",content:"数组内数据变化就会执行",key:"3"},{header:"回调函数中 return 作用",content:(0,a.jsxs)("div",{children:[(0,a.jsx)("div",{children:"1、清理上一次事件绑定,不清理会导致事件多次绑定"}),(0,a.jsx)("div",{children:"2、组件初始化不执行,组件销毁时执行,数据更新时先执行 return 函数"})]}),key:"4"},{header:"示例代码",content:(0,a.jsx)(a.Fragment,{children:(0,a.jsx)(s.Z,{initCode:"//闭包陷阱\nfunction Counter() {\n\tconst [count, setCount] = useState(0);\n  \n\tuseEffect(() => {\n\t  const id = setInterval(() => {\n\t\tsetCount(count + 1);\n\t  }, 1000);\n\t  return () => clearInterval(id);\n\t}, []);\n  \n\treturn <h1>{count}</h1>;\n  }\n\n  // 解决方案1\n  useEffect(() => {\n\tconst id = setInterval(() => {\n\t  setCount(count + 1);\n\t}, 1000);\n\treturn () => clearInterval(id);\n  }, [count]);\n  //缺陷\n  // 计时器不准了，因为每次 count 变化时都会销毁并重新计时。\n  // 频繁 生成/销毁 定时器带来了一定性能负担。\n\n  // 完美解决方案\n  useEffect(() => {\n\tconst id = setInterval(() => {\n\t  setCount(c => c + 1);\n\t}, 1000);\n\treturn () => clearInterval(id);\n  }, []);\n  \n  "})}),key:"5"}];e.default=function(){var n=(0,o.useState)(0),e=(0,r.Z)(n,2),t=e[0],s=e[1];(0,o.useEffect)((function(){return function(){}})),(0,o.useEffect)((function(){return function(){}}),[]),(0,o.useEffect)((function(){return function(){}}),[t]);return(0,a.jsxs)(c.Z,{children:[(0,a.jsx)(u.ZP,{type:"link",onClick:function(){s(t+1)},children:"+1"}),(0,a.jsx)(l,{value:t}),(0,a.jsx)(i.Z,{styleConfig:"1",defaultActiveKey:["0"],list:d})]})};var l=function(n){var e=n.value;return(0,o.useEffect)((function(){return function(){}})),(0,a.jsx)(a.Fragment,{children:e})}}}]);