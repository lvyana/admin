"use strict";(self.webpackChunkreact_app=self.webpackChunkreact_app||[]).push([[4190],{94805:function(e,t,r){var n=r(1413),d=(r(72791),r(36473)),s=r(80184);t.Z=function(e){var t=e.bordered,r=void 0!==t&&t,i=e.children,c=e.style,o=void 0===c?{}:c,l=e.hoverable,a=void 0!==l&&l,u=e.className;return(0,s.jsx)(s.Fragment,{children:(0,s.jsx)(d.Z,{hoverable:a,bordered:r,bodyStyle:(0,n.Z)({padding:"16px"},o),className:u,children:i})})}},68792:function(e,t,r){r.d(t,{Z:function(){return u}});var n=r(14916),d=(r(72791),r(66579)),s=r(85060),i=r(1413),c=r(22044),o=function(e){var t=e.list,r=e.styleConfig,n=e.style,d=e.bordered,s=(0,c.Z)().token,o={marginBottom:24,background:s.colorFillAlter,borderRadius:s.borderRadiusLG,border:"none"};return"1"===r?{list:t.map((function(e){return(0,i.Z)((0,i.Z)({},e),{},{style:o})})),style:{background:s.colorBgContainer},bordered:!1}:{list:t,styleConfig:r,style:n,bordered:d}},l=r(80184),a=n.Z.Panel,u=function(e){var t=e.list,r=e.defaultActiveKey,i=e.styleConfig,c=e.bordered,u=void 0===c||c,f=e.onChange,h=e.expandIcon,y=e.style,v=(0,d.C)(s.h2),x=o({list:t,styleConfig:i,style:y,bordered:u});return(0,l.jsx)("div",{children:(0,l.jsx)(n.Z,{bordered:x.bordered,defaultActiveKey:r,onChange:f,size:v,expandIcon:h,style:x.style,children:x.list.map((function(e){return(0,l.jsx)(a,{header:e.header,style:e.style,children:e.content},e.key)}))})})}},24861:function(e,t,r){r.r(t);var n=r(29439),d=r(72791),s=r(94805),i=r(68792),c=r(87309),o=r(57689),l=r(80184);t.default=function(){var e=(0,o.s0)(),t=(0,d.useState)(0),r=(0,n.Z)(t,2),a=r[0],u=r[1],f=(0,d.useState)(0),h=(0,n.Z)(f,2),y=h[0],v=h[1];(0,d.useEffect)((function(){v(11)}),[]),(0,d.useLayoutEffect)((function(){u(1),u(2),v(10)}),[]);var x=[{header:"执行机制",content:(0,l.jsxs)("div",{children:[(0,l.jsx)("div",{children:"1、浏览器渲染页面之前 DOM 更新之后同步执行,会阻塞渲染"}),(0,l.jsx)("div",{children:"2、建议修改 DOM 在useLayoutEffect执行"})]}),key:"0"},{header:"reader机制",content:(0,l.jsxs)("div",{children:[(0,l.jsx)("div",{children:"1、useLayoutEffect 内更新数据,会进行合并处理,只会 reader 一次"}),(0,l.jsx)("div",{children:"2、useLayoutEffect 内更新数据,会 reader 一次,不会和 useEffect 合并处理"}),(0,l.jsx)("div",{children:"3、useEffect 执行在渲染之后,更新数据会导致页面看到 0 -> 1,而 useLayoutEffect 在渲染之前更新,页面只会看到更新后的数据"})]}),key:"1"},{header:"参数执行机制",content:(0,l.jsxs)("div",{children:["参照 useEffect",(0,l.jsx)(c.ZP,{type:"link",onClick:function(){e("/react/hooks/useEffect")},children:"跳转"})]}),key:"2"},{header:"测试是否阻塞",content:(0,l.jsx)("div",{children:"useEffect 内执行1000000000循环,我认为 useEffect 也阻塞了渲染"}),key:"3"}];return(0,l.jsxs)(s.Z,{children:[(0,l.jsxs)("div",{children:["useLayoutEffect不会闪烁:",a]}),(0,l.jsxs)("div",{children:["useEffect会闪烁:",y]}),(0,l.jsx)(i.Z,{styleConfig:"1",defaultActiveKey:["0"],list:x})]})}}}]);