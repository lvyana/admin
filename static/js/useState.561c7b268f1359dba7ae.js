(self.webpackChunkreact_app=self.webpackChunkreact_app||[]).push([[9126],{68792:function(e,n,t){"use strict";t.d(n,{Z:function(){return u}}),t(72791);var r=t(16421),o=t(1413),i=t(83298),s=t(80184),u=function(e){var n=e.list,t=e.defaultActiveKey,u=e.styleConfig,c=e.bordered,d=void 0===c||c,l=e.onChange,a=e.expandIcon,f=function(e){var n=e.list,t=e.styleConfig,r=e.style,s=e.bordered,u=(0,i.Z)().token,c={marginBottom:24,background:u.colorFillAlter,borderRadius:u.borderRadiusLG,border:"none"};return"1"===t?{list:null==n?void 0:n.map((function(e){return(0,o.Z)((0,o.Z)({},e),{},{style:c})})),style:{background:u.colorBgContainer},bordered:!1}:{list:n,styleConfig:t,style:r,bordered:s}}({list:n,styleConfig:u,style:e.style,bordered:d});return(0,s.jsx)(r.Z,{bordered:f.bordered,defaultActiveKey:t,onChange:l,expandIcon:a,style:f.style,items:f.list})}},4429:function(e,n,t){"use strict";var r=t(29439),o=t(72791),i=t(94044),s=t.n(i),u=t(61293),c=(t(44350),t(99465),t(6639),t(27862),t(80184));n.Z=function(e){var n=e.initCode,t=void 0===n?"function add(a, b) {\n  return a + b;\n}":n,i=(0,o.useState)(t),d=(0,r.Z)(i,2),l=d[0],a=d[1];return(0,c.jsx)(s(),{value:l,onValueChange:function(e){return a(e)},highlight:function(e){return(0,u.highlight)(e,u.languages.js,"jsx")},padding:10,style:{fontSize:14},readOnly:!0,disabled:!0})}},34076:function(e,n,t){"use strict";t.d(n,{Z:function(){return h}});var r=t(1413),o=t(44925),i=t(29439),s=t(83298),u=t(72791),c=t(8570),d=t(64209),l=t(50082),a=t(80184),f=["node","inline","className","children"],h=function(e){var n=e.url,h=void 0===n?"":n,x=e.initContent,b=void 0===x?"":x,v=(0,u.useState)(b),j=(0,i.Z)(v,2),y=j[0],S=j[1];(0,u.useEffect)((function(){h&&g()}),[]);var g=function(){try{t(946)("./"+h).then((function(e){fetch(e.default).then((function(e){return e.text()})).then((function(e){S(e)}))}))}catch(e){}},m=(0,s.Z)().token;return(0,u.useEffect)((function(){var e;null===(e=document.querySelector("pre"))||void 0===e||e.style.setProperty("background-color",m.colorBgBase)}),[]),(0,a.jsx)("div",{children:(0,a.jsx)(c.D,{className:"iMarkdown_codeStyle__Hyxme",components:{code:function(e){e.node;var n=e.inline,t=e.className,i=e.children,s=(0,o.Z)(e,f),u=/language-(\w+)/.exec(t||"");return!n&&u?(0,a.jsx)(d.Z,(0,r.Z)((0,r.Z)({language:u[1],PreTag:"div"},s),{},{style:l.Z,children:String(i).replace(/\n$/,"")})):(0,a.jsx)("code",(0,r.Z)((0,r.Z)({className:t},s),{},{children:i}))}},children:y})})}},77982:function(e,n,t){"use strict";t.r(n);var r=t(29439),o=t(72791),i=t(87309),s=t(94805),u=t(68792),c=t(4429),d=t(18372),l=t(34076),a=t(80184);n.default=function(){var e=(0,o.useState)(0),n=(0,r.Z)(e,2),t=n[0],f=n[1],h=(0,o.useState)((function(){return 0})),x=(0,r.Z)(h,2),b=x[0],v=x[1],j=[{label:"useState在组件式编程里的基本用处",children:(0,a.jsx)("div",{children:"useState 是一个组件定义状态信息,所谓“状态”,就是该组件任意时刻都存放的各种数据"}),key:"0"},{label:"useState更新",children:(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("div",{children:"1、当组件更新state时,会触发组件的重新渲染,可以认为发生了局部刷新"}),(0,a.jsx)("div",{children:"2、在函数内多次更新,会合并处理"}),(0,a.jsx)("div",{children:"3、18之前手动合并处理unstable_batchedUpdates,18之后自动合并处理就不需要了"})]}),key:"1"},{label:"代码示例",children:(0,a.jsx)(a.Fragment,{children:(0,a.jsx)(c.Z,{initCode:"\nimport { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  function handleClick() {\n    setCount(count + 1);\n  }\n\n  return (\n    <button onClick={handleClick}>\n      You pressed me {count} times\n    </button>\n  );\n};"})}),key:"2"}];return(0,a.jsxs)(s.Z,{children:[(0,a.jsx)(i.ZP,{type:"link",onClick:function(){setTimeout((function(){return f(t+1)}),1e3),setTimeout((function(){return f(t+1)}),1e3),setTimeout((function(){return v(b+1)}),2e3)},children:"+1"}),t,b,(0,a.jsx)(u.Z,{styleConfig:"1",defaultActiveKey:["0"],list:j}),(0,a.jsx)(d.IuseSyncExternalStoreItem,{}),(0,a.jsx)(l.Z,{url:"useState.md"})]})}},18372:function(e,n,t){"use strict";t.r(n),t.d(n,{IuseSyncExternalStore:function(){return j},IuseSyncExternalStoreItem:function(){return y},default:function(){return m}});var r=t(1413),o=t(72791),i=t(37762),s=t(93433),u=0,c=[{id:u++,text:"Todo #1"}],d=[];function l(){var e,n=(0,i.Z)(d);try{for(n.s();!(e=n.n()).done;)(0,e.value)()}catch(e){n.e(e)}finally{n.f()}}var a={addTodo:function(){c=[].concat((0,s.Z)(c),[{id:u++,text:"Todo #"+u}]),l()},deleteTodo:function(){c=c.filter((function(e,n){return 0!==n})),l()},subscribe:function(e){return d=[].concat((0,s.Z)(d),[e]),function(){d=d.filter((function(n){return n!==e}))}},getSnapshot:function(){return c}},f=t(94805),h=t(83664),x=t(68792),b=t(80184),v={name:"Add todo",type:"key",btnType:"primary"},j=function(){var e=(0,o.useSyncExternalStore)(a.subscribe,a.getSnapshot);return(0,b.jsxs)(f.Z,{children:[(0,b.jsx)(h.E,{buttonItem:v,onClick:function(){return a.addTodo()}}),(0,b.jsx)("hr",{}),(0,b.jsx)("ul",{children:e.map((function(e){return(0,b.jsx)("li",{children:e.text},e.id)}))}),(0,b.jsx)(y,{}),(0,b.jsx)(g,{})]})},y=function(){var e=(0,o.useSyncExternalStore)(a.subscribe,a.getSnapshot);return(0,b.jsxs)("div",{children:[(0,b.jsx)("div",{children:"测试: useSyncExternalStore数据可以共享"}),(0,b.jsx)(h.E,{buttonItem:v,onClick:function(){return a.addTodo()}}),(0,b.jsx)(h.E,{buttonItem:(0,r.Z)((0,r.Z)({},v),{},{name:"delete todo"}),onClick:function(){return a.deleteTodo()}}),(0,b.jsx)("hr",{}),(0,b.jsx)("ul",{children:e.map((function(e){return(0,b.jsx)("li",{children:e.text},e.id)}))})]})},S=[{header:"useSyncExternalStore 参数说明",content:(0,b.jsxs)(b.Fragment,{children:[(0,b.jsx)("div",{children:"useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot)"}),(0,b.jsx)("div",{children:"subscribe函数得订阅这个store, 并且返回一个可以取消订阅的函数。"}),(0,b.jsx)("div",{children:"getSnapshot函数得可以从store里读取数据快照。"}),(0,b.jsx)("div",{children:"subscribe: 是一个函数，只有一个回调函数作为入参，并且使其订阅这个store. 当store发生改变的时候，这个回调函数应该得到执行，而且这会触发组件的重新渲染。subscribe函数应该返回一个可以取消订阅的方法。"}),(0,b.jsx)("div",{children:"getSnapshot: 是一个函数，返回一个组件中需要用到的store里的一个数据值的快照。当这个store没有改变的时候，重复调用getSnapshot必须返回同样的值。如果store发生改变并且返回的数据值不一样了（用Object.js做比较），那么Reacr重新渲染这个组件。"}),(0,b.jsx)("div",{children:"getServerSnapshot（可选参数）: 是一个函数，返回store数据的初始快照。只会在服务端渲染的时候使用，并且是在服务端渲染好的内容往客户端灌水的时候。服务端的快照必须和客户端的一致。并且通常是序列化后被发送到客户端的，如果你不传这个参数，在服务端渲染的时候会报错"}),(0,b.jsx)("div",{children:"当前你在组件渲染中使用到的store数据的快照"}),(0,b.jsx)("div",{children:"警告"}),(0,b.jsx)("div",{children:"调用getSnapshot返回的这个store数据快照不能修改，如果所依赖的store有可以更改的数据，当数据发生改变返回新的不可修改的数据，否则返回上一次缓存的数据快照。"}),(0,b.jsx)("div",{children:"如果在重新渲染的时候传来一个不同的subscribe函数，React会用新的subscribe重新订阅这个store。你可以通过在组件外面声明subscribe的方式来避免"})]}),key:"1"}],g=function(){return(0,b.jsx)(x.Z,{list:S})},m=j},946:function(e,n,t){var r={"./branch.md":[98595,8595],"./reactRouterDomV6.md":[91183,1183],"./useState.md":[39805,9805]};function o(e){if(!t.o(r,e))return Promise.resolve().then((function(){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}));var n=r[e],o=n[0];return t.e(n[1]).then((function(){return t.t(o,17)}))}o.keys=function(){return Object.keys(r)},o.id=946,e.exports=o}}]);
//# sourceMappingURL=useState.561c7b268f1359dba7ae.js.map