"use strict";(self.webpackChunkreact_app=self.webpackChunkreact_app||[]).push([[3443],{68792:function(n,e,t){t.d(e,{Z:function(){return c}});t(72791);var r=t(16421),i=t(1413),u=t(83298),l=function(n){var e=n.list,t=n.styleConfig,r=n.style,l=n.bordered,o=(0,u.Z)().token,c={marginBottom:24,background:o.colorFillAlter,borderRadius:o.borderRadiusLG,border:"none"};return"1"===t?{list:null==e?void 0:e.map((function(n){return(0,i.Z)((0,i.Z)({},n),{},{style:c})})),style:{background:o.colorBgContainer},bordered:!1}:{list:e,styleConfig:t,style:r,bordered:l}},o=t(80184),c=function(n){var e=n.list,t=n.defaultActiveKey,i=n.styleConfig,u=n.bordered,c=void 0===u||u,s=n.onChange,a=n.expandIcon,d=n.style,f=l({list:e,styleConfig:i,style:d,bordered:c});return(0,o.jsx)(r.Z,{bordered:f.bordered,defaultActiveKey:t,onChange:s,expandIcon:a,style:f.style,items:f.list})}},4429:function(n,e,t){var r=t(29439),i=t(72791),u=t(94044),l=t.n(u),o=t(61293),c=(t(44350),t(99465),t(6639),t(27862),t(80184));e.Z=function(n){var e=n.initCode,t=void 0===e?"function add(a, b) {\n  return a + b;\n}":e,u=(0,i.useState)(t),s=(0,r.Z)(u,2),a=s[0],d=s[1];return(0,c.jsx)(l(),{value:a,onValueChange:function(n){return d(n)},highlight:function(n){return(0,o.highlight)(n,o.languages.js,"jsx")},padding:10,style:{fontSize:14},readOnly:!0,disabled:!0})}},64241:function(n,e,t){t.r(e);var r=t(29439),i=t(72791),u=t(87309),l=t(94805),o=t(68792),c=t(4429),s=t(80184),a=[{label:"执行机制",children:"浏览器渲染之后执行,不会阻塞渲染",key:"0"},{label:"无参数",children:"每次 reader 都会执行",key:"1"},{label:"空数组 []",children:"组件初始化执行一次",key:"2"},{label:"数组并且有参数 [a,b]",children:"数组内数据变化就会执行",key:"3"},{label:"回调函数中 return 作用",children:(0,s.jsxs)("div",{children:[(0,s.jsx)("div",{children:"1、清理上一次事件绑定,不清理会导致事件多次绑定"}),(0,s.jsx)("div",{children:"2、组件初始化不执行,组件销毁时执行,数据更新时先执行 return 函数"})]}),key:"4"},{label:"示例代码",children:(0,s.jsx)(s.Fragment,{children:(0,s.jsx)(c.Z,{initCode:"//闭包陷阱\nfunction Counter() {\n\tconst [count, setCount] = useState(0);\n  \n\tuseEffect(() => {\n\t  const id = setInterval(() => {\n\t\tsetCount(count + 1);\n\t  }, 1000);\n\t  return () => clearInterval(id);\n\t}, []);\n  \n\treturn <h1>{count}</h1>;\n  }\n\n  // 解决方案1\n  useEffect(() => {\n\tconst id = setInterval(() => {\n\t  setCount(count + 1);\n\t}, 1000);\n\treturn () => clearInterval(id);\n  }, [count]);\n  //缺陷\n  // 计时器不准了，因为每次 count 变化时都会销毁并重新计时。\n  // 频繁 生成/销毁 定时器带来了一定性能负担。\n\n  // 完美解决方案\n  useEffect(() => {\n\tconst id = setInterval(() => {\n\t  setCount(c => c + 1);\n\t}, 1000);\n\treturn () => clearInterval(id);\n  }, []);\n  \n  "})}),key:"5"}];e.default=function(){var n=(0,i.useState)(0),e=(0,r.Z)(n,2),t=e[0],c=e[1];(0,i.useEffect)((function(){return function(){}})),(0,i.useEffect)((function(){return function(){}}),[]),(0,i.useEffect)((function(){return function(){}}),[t]);return(0,s.jsxs)(l.Z,{children:[(0,s.jsx)(u.ZP,{type:"link",onClick:function(){c(t+1)},children:"+1"}),(0,s.jsx)(d,{value:t}),(0,s.jsx)(o.Z,{styleConfig:"1",defaultActiveKey:["0"],list:a})]})};var d=function(n){var e=n.value;return(0,i.useEffect)((function(){return function(){}})),(0,s.jsx)(s.Fragment,{children:e})}}}]);